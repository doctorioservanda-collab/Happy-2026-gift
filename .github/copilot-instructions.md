## Project snapshot

- Frontend: Vite + React (TypeScript) in `src/` — entry `src/main.tsx` → `src/App.tsx`.
- Backend: Express server in `server/` (ESM). Routes in `server/routes/`, business logic in `server/modules/`.
- Integrations: Supabase client (`src/integrations/supabase/client.ts`), Ethers for wallet/contract interaction (`src/hook/useWallet.ts`, `src/abi/`).
- Styling: Tailwind + utility components under `src/component/` and `src/component/ui/` (Radix primitives).

## How to run (developer workflows)

- Install deps (root runs frontend + server install):

  npm run install:all

- Start frontend dev server only:

  npm run dev

- Start backend only (from repo root):

  npm run server

- Start both concurrently (dev):

  npm run start

- Build frontend for production:

  npm run build

Notes: `npm start` uses `concurrently` to launch `vite` and `server/index.js`. Server dev uses `node --watch index.js` via `server:dev`.

## Environment & secrets

- Frontend expects Vite env keys prefixed with `VITE_` (see `src/integrations/supabase/client.ts`):
  - `VITE_SUPABASE_URL`
  - `VITE_SUPABASE_PUBLISHABLE_KEY`

- Server envs are in `server/.env.example` and include:
  - `PORT`, `RPC_URL`, `PRIVATE_KEY`, `CONTRACT_ADDRESS_*`, `DATABASE_URL`

## Architecture & patterns an AI agent should know

- Clear separation: HTTP layer (Express routes in `server/routes/*`) is thin and delegates to business modules in `server/modules/*` — when adding endpoints, update both route and module.
- Frontend uses `@/*` path alias to reference files under `src/` (see `tsconfig.json` paths). Use imports like `@/integrations/supabase/client`.
- Supabase client is generated/boilerplate — comment at top of `src/integrations/supabase/client.ts` warns: "This file is automatically generated. Do not edit it directly." Prefer adding logic around it rather than editing generation output.
- Ethereum interactions live in hooks (e.g., `src/hook/useWallet.ts`) and contract ABIs are under `src/abi/`. Use `ethers` BrowserProvider in the browser.
- State & data fetching use React Query (`@tanstack/react-query`) — prefer query hooks and cache-aware updates.

## Conventions & code locations (examples)

- Add a new API route: create `server/routes/yourResource.js` (express Router) and implement business logic in `server/modules/yourResource.js`.
- UI components: shared primitives in `src/component/ui/`, page-level components in `src/pages/` and composed in `src/App.tsx`.
- Utilities: shared helpers in `src/lib/` (see `src/lib/utils.ts` which centralizes `cn()` class merging).

## Integration touchpoints

- Supabase: `src/integrations/supabase/` — auth persists to localStorage per generated client.
- Blockchain: `server/.env` RPC and private key for server-side tasks; frontend uses wallet injection (MetaMask) via `window.ethereum`.

## Quick guidance for common tasks

- Implementing an NFT endpoint example:
  - Route: `server/routes/nft.js` (add route handler)
  - Logic: `server/modules/nft.js` (implement `getAllNFTs`, `createNFT`)

- Debugging server: run `npm run server:dev` to use `node --watch` for autoreload of `server/index.js`.

## Files to inspect for decisions

- Entry points: `src/main.tsx`, `server/index.js`
- API pattern: `server/routes/*` & `server/modules/*`
- Auth & backend data: `src/integrations/supabase/*`, `server/.env.example`
- Wallet & blockchain: `src/hook/useWallet.ts`, `src/abi/`, `server/.env.example`

## Do / Don't for AI edits

- Do: Respect the `@/` alias and TypeScript types; run `npm run lint` before committing.
- Do: Preserve autogenerated files (Supabase client) and modify the code that uses them instead.
- Don't: Hardcode secrets — read from env (`VITE_` or server `.env`).

---

If anything here is unclear or you want more detail (examples of editing an endpoint, creating a new hook, or wiring a contract ABI), tell me which area and I'll expand or adjust the file.
